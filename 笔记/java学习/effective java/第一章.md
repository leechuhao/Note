## 创建和销毁对象

1. ### 使用静态工厂方法代替构造方法

   - 工厂方法名称可以更好了解返回的对象
   - 每次调用不必都创建新的对象
   - 可以返回任何继承了改对象的所有子对象（在方法中进行判断，按需求返回）
   - 在创建参数化类型对象的时候更简洁

   ```
   Map<String , List<String>> map = new HashMapString , List<String>>();
   
   public static <K, V> HashMap<K, V> newInstance() {
           return new HashMap<>();
       }
   Map<String, List<String>> map = newInstance();
   ```

2. ### 多个属性推荐使用builder模式

   首先，创建对象的方法通常是使用构造方法以及 getter/setter，当你使用多个参数的构造方法是显得非常复杂而且难以维护，而getter/setter方法把对象的属性分成不同的语句进行赋值，尤其是那些必要的属性，在多线程的时候可能会出现问题（其实平时没有多线程的时候没有觉得很麻烦）

   使用builer模式就显得很专业（划掉），代码易读，对于可变参数来说赋值非常方便，可以在builder() 方法中为某些属性自动赋值。

   所以在存在多个属性的时候builder模式比较适用，推荐使用 lombok 的@Builder 注解来实现；

3. ### 用私有构造器和枚举强化单例模式

   ```
   public class Demo{
   	//public static Demo INSTANCE = new Demo();
   	//private Demo(){}
   	
   	private static Demo INSTANCE = new Demo();
   	private Demo(){}
   	public static Demo getInstace(){
   		return INSTANCE
   	}	
   }
   
   public enum Demo{
   	INSTANCE;
   }
   ```

4. ### 使用私有构造器强化不可实例化的能力

   当希望本对象不被外部创建的时候，应该避免出现缺省的空构造函数。（使用私有构造器应该加上注释）

5. ### 避免创建不必要的实例

   当实例会被重复使用，就不应该浪费太多时间去创建。如果有些时候重用对象代价过大，就去创建新的，别太执着对象重用。

   这里引申一点，延迟初始化可能会导致代码更复杂

6. ### 消除过期的对象引用

   在一些自己管理内存的类中（比如Stack），如果没有显式清除引用，就不会被垃圾回收器自动回收，这样就会造成内存泄漏（但不要把显式清空对象引用作为规范，应该是作为例外，最好的办法是结束对象的生命周期）

   造成内存泄漏的主要原因有：

   1. 自己管理内存的类
   2. 缓存
   3. 监听器以及其他回调

7. ### 不要使用终结方法

   一定不要使用终结方法，使用终结方法确实可以增加对象回收的几率，但仍然无法确定对象什么时候会回收，甚至对象不会回收。

   而且终结方法会严重的影响性能

   唯一例外的是io类，这些类都有显式的终结方法