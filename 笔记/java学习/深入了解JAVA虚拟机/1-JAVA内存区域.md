### 程序计数器

可以看作当前线程所执行的字节码对应的行号指示器。每个线程都拥有独立的程序计数器。

- 如果线程正在执行一个JAVA方法，计数器记录的是正在执行的虚拟机字节码指令的地址；
- 如果正在执行的是Native方法，计数器值则为空
- 这个内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域

### java虚拟机栈

虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个**栈帧** 用于存储局部变量表、操作数栈、动态链接、方法接口等信息。方法从被调用到执行完成的过程也是栈帧从入栈到出栈的过程。

- java虚拟机栈是线程私有的，其生命周期与线程相同；
- **局部变量表**存放了编译期间可以知道的**各种基本数据类型**（boolean、byte、char、short、int、float、64bit{*long、double*}）、**对象引用**（reference类型，它不等同于对象本身，可能是只想对象起始地址的指针，也可能是只想一个代表对象的句柄或其它与此对象相关的位置）和**returnAddress类型**（指向一条字节码指令的地址）。
- 会抛出两种异常：StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度；OutOfMemoryError：动态扩展是无法申请到足够的内存

### 本地方法栈

- 和虚拟机栈类似，本地方法栈为虚拟机使用到的Native方法服务。


- 会抛出两种异常：StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度；OutOfMemoryError：动态扩展是无法申请到足够的内存

### java堆

虚拟机启动时创建，目的是存放对象实例，垃圾收集基本都采用分代收集算法

- java虚拟机所管理的内存中最大的一块，被所有线程共同使用。
- java堆中还可以细分为：新生代、老年代
  - 新生代：Eden、From Survivor、 To Survivor
- 通过-Xmx和-Xms控制堆内存的空间分配
- 当堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OutOfMemoryError

### 方法区

用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 所有线程共享
- 这个区域的垃圾回收目标主要针对常量池的回收和对类型的卸载
- 当方法区无法满足内存分配需求时， 将抛出OutOfMemoryError
- 运行时常量池存放编译期间生成的各种字面量和符号引用；**动态性**：可以在运行期间姜新的常量放入池中