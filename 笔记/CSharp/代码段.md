### 将Dictionary变为DataTable

```
Dictionary<String, String> map = new Dictionary<String, String>();
DataTable dt = new DataTable();
foreach(String key in map.Keys)
{
	dt.Columns.Add(key);
}
DataRow dr = dt.NewRow();
foreach(KeyValuePair<String, String> item in map)
{
	dr[item.Key] = item.Value;
}
dt.Rows.Add(dr);
return dt;
```

### 通用ToString()

```
public override string ToString()
        {
            PropertyDescriptorCollection coll = TypeDescriptor.GetProperties(this);
            StringBuilder builder = new StringBuilder();
            foreach (PropertyDescriptor pd in coll)
            {
                builder.Append(string.Format("  {0} : {1}  ", pd.Name, pd.GetValue(this).ToString()));
            }
            return builder.ToString();
        }
```

### 获取数据库信息

```
//需要引用mysql.data
public class MyConnection
    {
        private static MySqlConnection conn = new MySqlConnection(@"Host=127.0.0.1;Database=test;User=root;Password=lichuzxc;");

        public static void connect()
        {
            conn.Open();
        }

        public static DbConnection getConnect()
        {
            if (conn.State != System.Data.ConnectionState.Open)
            {
                conn.Open();
            }
            return conn;
        }

        public static DbDataAdapter getAdapter()
        {
            return new MySqlDataAdapter();
        }

        public static DbCommand getCmd()
        {
            return conn.CreateCommand();
        }
    }
```

### treeview动态生成

```
 private void treeFlush()
        {
            this.treeView1.Nodes.Clear();
            List<Baby> babys = babyService.findAll();
            List<Record> records = recordService.findAll();
            TreeNode[] tree = new TreeNode[babys.Count];

            for(int i=0; i<babys.Count; i++)
            {
                Baby baby = babys[i];
                List<Record> temp = new List<Record>();
                //对应婴幼儿的记录
                foreach(Record re in records)
                {
                    if(re.BabyID == baby.BabyID)
                    {
                        temp.Add(re);
                    }
                }
                //temp.Sort();
                TreeNode[] second = new TreeNode[temp.Count];
                for (int j = 0; j < temp.Count; j++)
                {
                    second[j] = new TreeNode("随访日期：" + temp[j].VisitDate.ToString());
                    second[j].Tag = temp[j];
                }

                tree[i] = new TreeNode("婴儿名称：" + baby.BabyName.ToString(), second);
                tree[i].Tag = baby;
            }
            this.treeView1.Nodes.AddRange(tree);
        }
```

### treeview节点点击事件

```
//treeview中的treeNode没有点击事件，在treeview的点击事件中获取当前点击的节点
//但还是不够完美，双击的时候不止触发了事件，而且也展开或收起了节点列表
void treeView1_DoubleClick(object sender, System.EventArgs e)
        {
            TreeNode node = this.treeView1.SelectedNode;
            Baby baby = new Baby();
            Record record = new Record();
            if (node.Tag.GetType().Equals(baby.GetType()))
            {
                this.tabControl1.SelectedIndex = 0;
                //只显示对应的页面
                //未完成
                this.userControl11.state();
                this.userControl11.setData((Baby)node.Tag);
                
            }
            if (node.Tag.GetType().Equals(record.GetType()))
            {
                this.tabControl1.SelectedIndex = 1;
                this.userControl31.state();
                this.userControl21.setDate((Baby)node.Parent.Tag);
                this.userControl31.setData((Record)node.Tag);
            }

            //MessageBox.Show(node.Tag.ToString());
        }
```

### 自定义用户控件

通常封装的方法有：

- getData()//从控件中反序列化一个对象
- setDate()//将对象序列化，展示出来
- clear()//清空控件中的信息，回到默认的状态
- submit()//执行控件中的数据操作方法
- validate()//校验数据

尽量不要从控件中操作父窗口（比如js的dom对象操作）

### 数据库操作

实现需求的时候，注意发现通用的部分，统计功能中都需要获取最新的记录，再进行数据的统计操作。可以把所有的记录取到程序中，减少数据库的操作。