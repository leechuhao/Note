java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中读取变量这样的底层细节。

主内存存储所有的变量；每条线程都有独立的工作内存，保存被该线程使用到的变量的主内存拷贝。

### 内存件相互操作

- lock
- unlock


- read：作用与主内存的变量，把一个变量的值从主内存传输到线程的工作内存中
- load：作用于工作内存的变量，把read擦左从主内存读取到的变量值放入工作内存的变量副本中


- use：作用于工作内存，把变量值传递给执行引擎
- assign：赋值


- store
- write

#### 特殊变量volatile

1. 保证变量对所有线程的可见性。
2. 禁止指令重排序优化。指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应的电路单元处理。能保证所有依赖赋值结果的地方都能获取到正确的结果。

### 原子性

由java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，我们基本可以认为基本数据类型的访问读写是具备原子性的。

### 可见性

可见性是指当一个线程修改了共享变量的值，其他线程能立即得知这个修改。

### 有序性

如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。

### 先行发生原则

先行发生是java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观测到，“影响”包括修改内存中共享变量的值、发送子信息、调用了方法等。

1. 程序次序规则
2. 管程锁定规则
3. volatile变量规则
4. 线程启动规则
5. 线程终止规则
6. 线程中断规则
7. 对象终结规则
8. 传递性

### java实现线程

1. 使用内核线程（KLT）实现
2. 使用用户线程（UT）实现
3. 使用用户线程加轻量级进程（LWP）混合实现
