### Serial收集器/Serial Old收集器

![img](.\微信截图_20180410160146.png)

### ParNew收集器/Serial Old收集器

![微信截图_20180410160308](.\微信截图_20180410160308.png)

### Parallel Scavenge收集器/Parallel Old收集器

![微信截图_20180410160406](.\微信截图_20180410160406.png)

​	Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）

### CMS收集器

初始标记：仅仅是标记一下GC Roots能直接关联到的对象，速度很快

并发标记：GC Roots的Tracing过程

重新标记：为了修正并发阶段期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录

并发清除：和用户进程一起运行进行垃圾收集

![微信截图_20180410160837](.\微信截图_20180410160837.png)

缺点：

1. 对CPU资源很敏感
2. 无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生
3. CMS是基于标记——清除算法实现的，所以垃圾收集结束后会有大量内存空间碎片产生。

### G1收集器

并发与并发：充分利用多CPU、多核环境下的硬件优势，缩短了stop the world的时间。

分代收集：能采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获得更好的收集效果

空间整合：从整体上看基于标记——整理算法；从局部上来看是基于复制算法实现的。这意味着G1算法不会产生空间碎片。

可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征。

讲Java堆分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

G1收集器的步骤：

1. 初始标记：标记GC Roots能直接关联到的对象，并修改TAMS（next top at mark start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，需要停顿线程， 耗时短。
2. 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时长，但可以与用户进程并发。
3. 最终标记：把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并发执行。
4. 筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划（这个阶段其实可以与用户进程并发，但因为只回收一部分Region，时间是用户可控制的，且停顿用户线程能大幅提高效率）

![微信截图_20180410160914](.\微信截图_20180410160914.png)